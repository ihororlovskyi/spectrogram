// https://www.shadertoy.com/view/XlfGRj
// By Pablo Roman Andrioli

const float formuparam = 0.53;
const float stepsize = 0.1;

const float zoom = 0.800;
const float tile = 0.850;
const float speed = 0.0001;

const float brightness = 0.0015;
const float darkmatter = 0.300;
const float distfading = 0.730;
const float saturation = 0.850;

half4 main(float2 fragCoord) {
  // get coords and direction
  float2 uv = fragCoord.xy / n1.xy - 0.5;
  uv.y *= n1.y / n1.x;
  float3 dir = float3(uv * zoom, 1.0);
  float time = n0 * speed + 0.25;

  // mouse rotation (using normalized screen center for now)
  float a1 = 0.5 + 0.5 * 2.0;
  float a2 = 0.8 + 0.5 * 2.0;
  float2x2 rot1 = float2x2(cos(a1), sin(a1), -sin(a1), cos(a1));
  float2x2 rot2 = float2x2(cos(a2), sin(a2), -sin(a2), cos(a2));
  dir.xz *= rot1;
  dir.xy *= rot2;
  float3 from = float3(1.0, 0.5, 0.5);
  from += float3(time * 2.0, time, -2.0);
  from.xz *= rot1;
  from.xy *= rot2;

  // volumetric rendering
  float s = 0.1, fade = 1.0;
  float3 v = float3(0.0);
  for (int r = 0; r < 20; r++) {
    float3 p = from + s * dir * 0.5;
    p = abs(float3(tile) - mod(p, float3(tile * 2.0))); // tiling fold
    float pa = 0.0, a = pa = 0.0;
    for (int i = 0; i < 17; i++) {
        p = abs(p) / dot(p, p) - formuparam; // the magic formula
        a += abs(length(p) - pa); // absolute sum of average change
        pa = length(p);
    }
    float dm = max(0.0, darkmatter - a * a * 0.001); // dark matter
    a *= a * a; // add contrast
    if (r > 6) fade *= 1.0 - dm; // dark matter, don't render near
    v += fade;
    v += float3(s, s * s, s * s * s * s) * a * brightness * fade; // coloring based on distance
    fade *= distfading; // distance fading
    s += stepsize;
  }
  v = mix(float3(length(v)), v, saturation); // color adjust
  return half4(v * 0.01, 1.0);
}
